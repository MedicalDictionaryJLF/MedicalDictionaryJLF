<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Medical Dictionary — web copy</title>
  <style>
  :root{
    /* GREEN THEME */
    --brand:#15803d;        /* emerald/green */
    --brand-2:#166534;      /* darker green */
    --bg:#f3f6f4;
    --card:#ffffff;
    --text:#1f2937;
    --muted:#6b7280;
    --border:rgba(17,24,39,.10);
    --shadow:0 8px 30px rgba(17,24,39,.10);
    --radius:14px;

    /* Optional hero background: put a file next to index.html, e.g. "hero.jpg", then uncomment */
    /* --hero-bg: url('hero.jpg'); */
  }

  *{box-sizing:border-box;font-family:ui-sans-serif,system-ui,-apple-system,Segoe UI,Roboto,Arial,sans-serif}
  html,body{height:100%}
  body{margin:0;background:var(--bg);color:var(--text);line-height:1.35}

  /* Header */
  header{
    position:sticky;top:0;z-index:50;
    display:flex;justify-content:space-between;align-items:center;
    padding:12px 18px;
    background:linear-gradient(180deg,var(--brand),var(--brand-2));
    color:white;
    box-shadow:0 6px 20px rgba(0,0,0,.14);
  }
  .header-left{display:flex;align-items:center;gap:14px;min-width:240px}
  header h1{margin:0;font-size:18px;letter-spacing:.2px;font-weight:650}
  .whoami{
    display:inline-flex;align-items:center;gap:8px;
    padding:6px 10px;
    border-radius:999px;
    background:rgba(255,255,255,.14);
    border:1px solid rgba(255,255,255,.18);
    font-size:13px;
    white-space:nowrap;
  }
  .whoami strong{font-weight:700}

  /* Bigger cog */
  .settings-btn{
    background:rgba(255,255,255,.10);
    border:1px solid rgba(255,255,255,.18);
    border-radius:14px;
    color:white;
    cursor:pointer;
    padding:12px;                 /* bigger */
  }
  .settings-btn:hover{background:rgba(255,255,255,.16)}
  .settings-btn svg{width:24px;height:24px;fill:currentColor;display:block} /* bigger icon */

  /* Layout */
  main{padding:22px}
  .screen{max-width:1100px;margin:0 auto;min-height:calc(100vh - 74px);display:flex;flex-direction:column;align-items:center;justify-content:center}
  .hidden{display:none!important}
  .screen h2{
    width:min(920px, 100%);
    margin:0 0 12px 0;
  }

  /* Cards & controls */
  .card{
    width:min(920px, 100%);
    background:var(--card);
    padding:18px;
    border-radius:var(--radius);
    border:1px solid var(--border);
    box-shadow:var(--shadow);
  }

  input,select,textarea,button{font-size:16px;padding:10px 12px}
  input,textarea,select{
    width:100%;
    margin:8px 0;
    border-radius:12px;
    border:1px solid var(--border);
    background:#fff;
    outline:none;
  }
  input:focus,textarea:focus,select:focus{
    border-color:rgba(21,128,61,.45);
    box-shadow:0 0 0 4px rgba(21,128,61,.15)
  }
  textarea{min-height:92px;resize:vertical}

  button{
    cursor:pointer;
    border-radius:12px;
    border:1px solid var(--border);
    background:#fff;
    transition:transform .03s ease, background .15s ease, border-color .15s ease;
  }
  button:hover{background:#f8fafc}
  button:active{transform:translateY(1px)}
  button.primary{background:var(--brand);border-color:rgba(255,255,255,.0);color:#fff}
  button.primary:hover{background:#137a38}
  button.danger{background:#fff;border-color:rgba(220,38,38,.25);color:#991b1b}
  button.danger:hover{background:#fff5f5}

  .row{display:flex;gap:10px;margin-top:10px;flex-wrap:wrap}
  .row > *{flex:1 1 180px}

  .muted{color:var(--muted);margin-top:8px}
  .small{font-size:13px;color:var(--muted)}
  .scrollable{max-height:62vh;overflow:auto;padding-right:4px}

  /* Settings sidebar */
  #settings-sidebar{
    position:fixed;top:0;right:-340px;width:340px;height:100vh;
    background:white;box-shadow:-2px 0 35px rgba(0,0,0,0.18);
    transition:right 0.25s ease;padding:20px;z-index:1000;
    border-left:1px solid var(--border);
  }
  #settings-sidebar.open{right:0}

  /* overlay (fix color) */
  #settings-overlay{
    position:fixed;top:0;left:0;width:100%;height:100%;
    background:rgba(0,0,0,.40);
    opacity:0;visibility:hidden;transition:opacity 0.2s;z-index:999
  }
  #settings-overlay.open{opacity:1;visibility:visible}

  .modal-overlay{
    position:fixed;top:0;left:0;width:100%;height:100%;
    background:rgba(0,0,0,.45);
    display:flex;align-items:center;justify-content:center;
    z-index:998;
  }
  .modal{
    width:min(520px, 92%);
    background:#fff;
    border:1px solid var(--border);
    border-radius:16px;
    padding:18px;
    box-shadow:var(--shadow);
  }
  .modal h3{margin:0 0 8px 0}
  .modal p{margin:0 0 14px 0;color:var(--muted)}

  .settings-block{
    padding:12px;
    border:1px solid var(--border);
    border-radius:14px;
    background:#fff;
    margin-top:12px;
  }
  .settings-block h4{margin:0 0 10px 0;font-size:14px}
  .settings-actions button{width:100%;margin-top:10px}
  .settings-status{
    margin-top:10px;
    font-size:13px;
    color:var(--muted);
  }

  /* --- HERO (Menu screen) --- */
  #screen-menu{
    max-width:none;width:100%;
    padding:0;
  }
  #screen-menu .hero{
    width:100%;
    min-height:calc(100vh - 74px);
    display:flex;align-items:center;justify-content:center;
    background:
      linear-gradient(180deg, rgba(0,0,0,.55), rgba(0,0,0,.62)),
      var(--hero-bg, radial-gradient(1200px 600px at 50% 30%, rgba(255,255,255,.18), rgba(0,0,0,.22))),
      linear-gradient(135deg, #052e16, #14532d); /* deep green */
    background-size:cover;
    background-position:center;
    padding:26px;
  }
  #screen-menu .hero-inner{
    width:min(980px, 100%);
    text-align:center;
    color:#fff;
  }
  #screen-menu .hero-title{
    font-size:42px;
    font-weight:750;
    letter-spacing:.2px;
    margin:0 0 8px 0;
    text-shadow:0 10px 28px rgba(0,0,0,.45);
  }
  #screen-menu .hero-sub{
    margin:0 0 16px 0;
    font-size:18px;
    opacity:.92
  }
  #screen-menu .hero-card{
    margin:18px auto 0;
    width:min(920px, 100%);
    background:rgba(255,255,255,.10);
    border:1px solid rgba(255,255,255,.18);
    border-radius:18px;
    padding:18px;
    backdrop-filter: blur(8px);
    box-shadow:0 18px 60px rgba(0,0,0,.25);
  }

  /* Language buttons like your app screenshot */
  .lang-grid{
    display:grid;
    grid-template-columns:1fr;
    gap:12px;
    margin-top:12px;
  }
  .lang-grid button{
    padding:14px 14px;
    font-weight:650;
    background:rgba(255,255,255,.16);
    border:1px solid rgba(255,255,255,.22);
    color:#fff;
  }
  .lang-grid button:hover{background:rgba(255,255,255,.22)}
  .lang-grid button:active{transform:translateY(1px)}

  
  /* Light variant of language grid (for white cards like Login screen) */
  .lang-grid.light button{
    color:var(--text);
    background:#fff;
    border:1px solid var(--border);
  }
  .lang-grid.light button:hover{background:#f8fafc}
/* Cambridge-like search panel */
  #screen-search .card, #screen-entry .card, #screen-quiz .card, #screen-submenu .card, #screen-login .card{
    padding:20px;
  }
  #screen-submenu .card{
    display:flex;
    flex-direction:column;
    gap:10px;
  }
  #screen-submenu .card button{
    width:100%;
  }
  #screen-search .card{
    border-radius:18px;
  }
  #search-input{
    font-size:18px;
    padding:14px 14px;
    border-radius:14px;
  }
  #search-results{margin-top:14px}
  .result{
    padding:14px 14px;
    border:1px solid var(--border);
    border-radius:14px;
    background:#fff;
    box-shadow:0 6px 16px rgba(17,24,39,.06);
    margin:10px 0;
  }
  .result strong{font-size:18px}
  .kv{
    display:grid;
    grid-template-columns:150px 1fr;
    gap:8px 14px;
    margin-top:10px;
    align-items:start;
  }
  .k{color:var(--muted);font-size:13px}
  .v{color:var(--text);font-size:15px}

  @media (max-width:700px){
    #screen-menu .hero-title{font-size:34px}
    .kv{grid-template-columns:110px 1fr}
    .whoami{display:none} /* keep header clean on small screens */
  }
</style>
</head>
<body>
  <div id="app">
    <header>
      <div class="header-left">
        <h1 id="app-title">Medical Dictionary</h1>

        <!-- shown ONLY after login -->
        <div id="header-whoami" class="whoami hidden">
          Logged in as: <strong id="header-user">—</strong>
        </div>
      </div>

      <!-- SETTINGS COG: hidden until logged in -->
      <button type="button" class="settings-btn hidden" id="settings-toggle" aria-label="Settings">
        <svg viewBox="0 0 24 24"><path d="M19.14 12.94c.04-.3.06-.61.06-.94 0-.32-.02-.64-.07-.94l2.03-1.58c.18-.14.23-.41.12-.61l-1.92-3.32c-.12-.22-.37-.29-.59-.22l-2.39.96c-.5-.38-1.03-.7-1.62-.94l-.36-2.54c-.04-.24-.24-.41-.48-.41h-3.84c-.24 0-.43.17-.47.41l-.36 2.54c-.59.24-1.13.57-1.62.94l-2.39-.96c-.22-.08-.47 0-.59.22L2.74 8.87c-.12.21-.08.47.12.61l2.03 1.58c-.05.3-.09.63-.09.94s.02.64.07.94l-2.03 1.58c-.18.14-.23.41-.12.61l1.92 3.32c.12.22.37.29.59.22l2.39-.96c.5.38 1.03.7 1.62.94l.36 2.54c.05.24.24.41.48.41h3.84c.24 0 .44-.17.47-.41l.36-2.54c.59-.24 1.13-.56 1.62-.94l2.39.96c.22.08.47 0 .59-.22l1.92-3.32c.12-.22.07-.47-.12-.61l-2.01-1.58zM12 15.6c-1.98 0-3.6-1.62-3.6-3.6s1.62-3.6 3.6-3.6 3.6 1.62 3.6 3.6-1.62 3.6-3.6 3.6z"/></svg>
      </button>
    </header>

    <div id="settings-overlay"></div>
    <div id="settings-sidebar">
      <h3 style="margin:0 0 10px 0">Settings</h3>

      <div class="settings-block">
        <h4>Language</h4>
        <label for="language" class="small">App language</label>
        <select id="language">
          <option value="English">English</option>
          <option value="Deutch">Deutch</option>
          <option value="Slovensky">Slovensky</option>
          <option value="Spanish">Español</option>
          <option value="Norwegian">Norsk</option>
          <option value="Icelandic">Íslenska</option>
        </select>
      </div>

      <!-- MOVED HERE: Sync + Return to menu (only useful when logged in; buttons remain but can be used anytime) -->
      <div class="settings-block">
        <h4>Account & Sync</h4>

        <div class="settings-actions">
          <button type="button" id="btn-sync" class="primary">Sync</button>
          <button type="button" id="to-menu">Back to Language Menu</button>
          <button type="button" id="to-login-from-settings">Return to Login</button>
        </div>

        <div class="settings-status">
          Sync: <span id="sync-status">not synced</span> · Unsynced changes: <span id="sync-dirty-count">0</span>
        </div>

        <div class="settings-status" style="margin-top:8px">
          Logged in as: <strong id="current-user">(none)</strong>
        </div>
      </div>
    </div>

    <div id="guest-overlay" class="modal-overlay hidden">
      <div class="modal" role="dialog" aria-modal="true" aria-labelledby="guest-title">
        <h3 id="guest-title">Continue without account?</h3>
        <p>Your progress won't be saved. To save your progress, login or register your account.</p>
        <div class="row">
          <button type="button" id="guest-continue" class="primary">Continue</button>
          <button type="button" id="guest-back">Back</button>
        </div>
      </div>
    </div>

    <main>
      <section id="screen-menu" class="screen">
        <div class="hero">
          <div class="hero-inner">
            <h2 class="hero-title">Medical Dictionary</h2>
            <p class="hero-sub" data-i18n="welcome">Welcome</p>

            <div class="hero-card">
              <h3 style="margin:0 0 8px 0;font-weight:700" data-i18n="choose_language">Choose language</h3>
              <p style="margin:0 0 12px 0;font-weight:100;font-size:14px" data-i18n="language_settings">May later change in settings</p>
              <div class="lang-grid">
                <button type="button" class="lang-btn" data-lang="English">English</button>
                <button type="button" class="lang-btn" data-lang="Deutch">Deutch</button>
                <button type="button" class="lang-btn" data-lang="Slovensky">Slovensky</button>
                <button type="button" class="lang-btn" data-lang="Spanish">Español</button>
                <button type="button" class="lang-btn" data-lang="Norwegian">Norsk</button>
                <button type="button" class="lang-btn" data-lang="Icelandic">Íslenska</button>
              </div>

              <div class="row" style="margin-top:16px">
                <button type="button" id="to-login" class="primary" data-i18n="Login">Login</button>
                <button type="button" id="to-register" data-i18n="Register">Register</button>
              </div>

              <div class="row" style="margin-top:10px">
                <button type="button" id="continue-guest">Continue without account</button>
              </div>

              <div class="small" style="margin-top:10px;opacity:.9" data-i18n="please_note">Please note: This web version is still in development…
                <br />
              </div>
            </div>
          </div>
        </div>
      </section>

      <section id="screen-login" class="screen hidden">
        <h2 id="login-title" data-i18n="Login or Register">Login or Register</h2>
<div class="card">
          <div id="login-status" class="muted" style="display:none;margin-bottom:10px;padding:10px;border-radius:8px;"></div>
          <div id="login-form">
            <input id="username" placeholder="Username" data-i18n-placeholder="Username" />
            <input id="password" type="password" placeholder="Password" data-i18n-placeholder="Password" />
            <div class="row">
              <button type="button" id="btn-login" data-i18n="Login">Login</button>
              <button type="button" id="btn-show-register" data-i18n="Register">Register</button>
            </div>
            <p id="login-msg" class="muted"></p>
          </div>

          <div id="register-form" class="hidden">
            <input id="reg-username" placeholder="Username" />
            <input id="reg-password" type="password" placeholder="Password" />
            <input id="reg-password-confirm" type="password" placeholder="Confirm password" />
            <div class="row">
              <button type="button" id="btn-register" data-i18n="Register">Create account</button>
              <button type="button" id="btn-show-login">Back</button>
            </div>
            <p id="register-msg" class="muted"></p>
          </div>
        </div>
      </section>

      <section id="screen-submenu" class="screen hidden">
        <h2 id="welcome-title">Welcome</h2>
        <div class="card">
          <button type="button" id="to-search" data-i18n="search">Search Terms</button>
          <button type="button" id="to-entry" data-i18n="add_term">Add Term</button>
          <button type="button" id="to-quiz" data-i18n="quiz">Quiz</button>
          <button type="button" id="to-muscle-training">Muscle training</button>
          <button type="button" id="to-anamnesis">Anamnesis</button>
          <button type="button" id="to-links">Links</button>

          <!-- REMOVED FROM HERE:
               - Sync button (moved to Settings)
               - Back to Language Menu button (moved to Settings)
               - Logged in as line (now in header + Settings)
          -->
        </div>
      </section>

      <section id="screen-search" class="screen hidden">
        <h2 data-i18n="search">Search</h2>
        <div class="card">
          <input id="search-input" placeholder="Enter term (min 2 chars)" data-i18n-placeholder="enter_term" />
          <div id="search-results"></div>
          <div class="row">
            <button type="button" id="search-back" data-i18n="back">Back</button>
          </div>
        </div>
      </section>

      <section id="screen-entry" class="screen hidden">
        <h2 data-i18n="add_term">Add Term</h2>
        <div class="card scrollable">
          <div id="entry-fields">
            <input data-field="latin_translation" placeholder="Latin translation" />
            <input data-field="english_translation" placeholder="English translation" />
            <textarea data-field="english_definition" placeholder="English definition"></textarea>
            <input data-field="german_translation" placeholder="German translation" />
            <textarea data-field="german_definition" placeholder="German definition"></textarea>
          </div>
          <div class="row">
            <button type="button" id="save-term" data-i18n="Save Term">Save Term</button>
            <button type="button" id="entry-back" data-i18n="back">Back</button>
          </div>
          <p id="entry-msg" class="muted"></p>
        </div>
      </section>

      <section id="screen-quiz" class="screen hidden">
        <h2 data-i18n="quiz">Quiz</h2>
        <div class="card">
          <div class="row">
            <label>From:</label>
            <select id="quiz-from">
              <option value="english_translation">English</option>
              <option value="german_translation">German</option>
              <option value="slovak_translation">Slovak</option>
              <option value="latin_translation">Latin</option>
            </select>
            <label>To:</label>
            <select id="quiz-to">
              <option value="latin_translation">Latin</option>
              <option value="english_translation">English</option>
              <option value="german_translation">German</option>
              <option value="slovak_translation">Slovak</option>
            </select>
          </div>
          <div id="quiz-area"></div>
          <div class="row">
            <button type="button" id="start-quiz" data-i18n="start_quiz">Start</button>
            <button type="button" id="quiz-back" data-i18n="back">Back</button>
          </div>
          <p id="quiz-score" class="muted"></p>
        </div>
      </section>

    </main>
  </div>

  <script type="module">
import { createClient } from "https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2/+esm";

const SUPABASE_URL = "https://glrxzhmhgzhabqzhmsiu.supabase.co";
const SUPABASE_ANON_KEY = "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6Imdscnh6aG1oZ3poYWJxemhtc2l1Iiwicm9sZSI6ImFub24iLCJpYXQiOjE3NjY4MzM3NzUsImV4cCI6MjA4MjQwOTc3NX0.Nzx3cHnPpn1awhQyNhjwKd2GUFnzieVR6uz7L-2eKrs";




// --- DOM helpers (prevents crashes if an element is missing) ---
const $ = (id)=>document.getElementById(id);
const on = (id, ev, fn)=>{ const el=$(id); if(!el){ console.warn('Missing element:', id); return; } el.addEventListener(ev, fn); };
// ===== Supabase Storage: base CSV files for offline cache =====
// Bucket name must match your Supabase Storage bucket exactly
const STORAGE_BUCKET = "Medical terms CSV";
const STORAGE_FILES = [
  { filename: "medical_terms.csv", cacheId: "base/medical_terms.csv" },
  { filename: "App translations.csv", cacheId: "base/App translations.csv" },
];
let supabase = null;

function initSupabase() {
  if (!SUPABASE_ANON_KEY || SUPABASE_ANON_KEY.startsWith("PASTE_")) {
    console.warn("Supabase anon key missing – running local-only mode");
    return null;
  }
  if (!supabase) {
    supabase = createClient(SUPABASE_URL, SUPABASE_ANON_KEY);
  }
  return supabase;
}


// ===== Offline cache via IndexedDB (stores downloaded CSVs) =====
const IDB_NAME = "mdict_cache";
const IDB_STORE = "files";
const IDB_VERSION = 1;

function idbOpen(){
  return new Promise((resolve, reject) => {
    const req = indexedDB.open(IDB_NAME, IDB_VERSION);
    req.onupgradeneeded = () => {
      const db = req.result;
      if(!db.objectStoreNames.contains(IDB_STORE)){
        db.createObjectStore(IDB_STORE);
      }
    };
    req.onsuccess = () => resolve(req.result);
    req.onerror = () => reject(req.error);
  });
}

async function idbGet(key){
  const db = await idbOpen();
  return new Promise((resolve, reject) => {
    const tx = db.transaction(IDB_STORE, "readonly");
    const store = tx.objectStore(IDB_STORE);
    const req = store.get(key);
    req.onsuccess = () => resolve(req.result || null);
    req.onerror = () => reject(req.error);
  });
}

async function idbSet(key, value){
  const db = await idbOpen();
  return new Promise((resolve, reject) => {
    const tx = db.transaction(IDB_STORE, "readwrite");
    const store = tx.objectStore(IDB_STORE);
    const req = store.put(value, key);
    req.onsuccess = () => resolve(true);
    req.onerror = () => reject(req.error);
  });
}

// ===== Supabase Storage helpers (download base CSVs) =====
function storageClient(){
  const c = initSupabase();
  if(!c) return null;
  return c.storage.from(STORAGE_BUCKET);
}

async function storageListMeta(){
  const sc = storageClient();
  if(!sc) return null;
  try{
    const { data, error } = await sc.list("", { limit: 1000 });
    if(error) throw error;

    const meta = {};
    for(const f of (data || [])){
      meta[f.name] = f;
    }
    return meta;
  }catch(e){
    console.warn("Storage list failed (will fall back to direct downloads):", e.message || e);
    return null;
  }
}

async function downloadFromStorage(filename){
  const sc = storageClient();
  if(!sc) throw new Error("Supabase not configured");
  const { data, error } = await sc.download(filename);
  if(error) throw error;
  return await data.text();
}

/**
 * Refresh cached base CSV files on login.
 * - Downloads files from Supabase Storage to IndexedDB if remote updated_at changed.
 */
async function refreshBaseFilesCache(){
  // Goal: ensure the newest CSVs are available on every page load.
  // Strategy:
  // 1) Try list() to get updated_at and avoid unnecessary downloads
  // 2) If list() fails (private bucket / RLS / CORS), fall back to direct download for each file
  const meta = await storageListMeta();

  for(const f of STORAGE_FILES){
    const cacheKey = "file:" + f.cacheId;
    let cached = null;

    try{ cached = await idbGet(cacheKey); }catch(e){ cached = null; }

    const remote = meta ? meta[f.filename] : null;
    const remoteUpdated = remote?.updated_at || remote?.created_at || null;
    const cachedUpdated = cached?.updated_at || null;

    // If we can't read remoteUpdated (meta missing), force a download attempt.
    const needsUpdate = !meta || !cached || !cachedUpdated || (remoteUpdated && remoteUpdated !== cachedUpdated);

    if(needsUpdate){
      try{
        const text = await downloadFromStorage(f.filename);
        await idbSet(cacheKey, {
          text,
          updated_at: remoteUpdated,      // may be null; that's ok
          filename: f.filename,
          saved_at: new Date().toISOString()
        });
      }catch(e){
        console.warn("Storage download failed for", f.filename, "(continuing):", e.message || e);
      }
    }
  }
}

/**
 * Load base CSV:
 * 1) IndexedDB cache (if present)
 * 2) local file (fallback)
 */
async function loadBaseFile(filename){
  const entry = STORAGE_FILES.find(x => x.filename === filename);
  const cacheKey = "file:" + (entry ? entry.cacheId : ("base/" + filename));

  const cached = await idbGet(cacheKey);
  if(cached?.text) return cached.text;

  return await loadFile(filename);
}


function setLoginStatus(text, type = "info") {
  const el = document.getElementById("login-status");
  if (!el) return;

  el.textContent = String(text || "");
  el.style.display = "block";

  el.style.background =
    type === "ok" ? "#eafaf0" :
    type === "error" ? "#fde8e8" :
    "#ecfdf5";
}

function clearLoginStatus(){
  const el = document.getElementById("login-status");
  if(!el) return;
  el.style.display = "none";
  el.textContent = "";
  el.style.background = "";
}

function normalizeLoginIdentifier(input){
  const raw = String(input || "").trim().toLowerCase();
  if(!raw) return "";
  if(raw.includes("@")) return raw;
  return raw + "@medicaldict.local";
}

async function supaGetSession(){
  const c = initSupabase();
  if(!c) return null;
  const { data, error } = await c.auth.getSession();
  if(error) throw error;
  return data.session;
}

async function supaSignUp(email, password){
  const c = initSupabase();
  if(!c) throw new Error("Supabase not configured");
  const { error } = await c.auth.signUp({ email, password });
  if(error) throw error;
}

async function supaSignIn(email, password){
  const c = initSupabase();
  if(!c) throw new Error("Supabase not configured");
  const { error } = await c.auth.signInWithPassword({ email, password });
  if(error) throw error;
}

async function supaSignOut(){
  const c = initSupabase();
  if(!c) return;
  const { error } = await c.auth.signOut();
  if(error) throw error;
}

// -------- Supabase schema (Option B: normalized tables) --------
const USER_TERMS_TABLE = "user_terms";
const USER_REVIEW_TABLE = "user_review";

// -------- Offline cache (localStorage) --------
function cacheKeyTerms(){ return "cache/user_terms"; }
function cacheKeyReview(){ return "cache/user_review"; }

function readJsonLS(key, fallback){
  try{ const s = localStorage.getItem(key); return s ? JSON.parse(s) : fallback; }
  catch(e){ return fallback; }
}
function writeJsonLS(key, val){ localStorage.setItem(key, JSON.stringify(val)); }

function getLocalTerms(){ return readJsonLS(cacheKeyTerms(), []); }
function setLocalTerms(terms){ writeJsonLS(cacheKeyTerms(), terms || []); updateDirtyCount(); }

function getLocalReview(){ return readJsonLS(cacheKeyReview(), []); }
function setLocalReview(items){ writeJsonLS(cacheKeyReview(), items || []); updateDirtyCount(); }

function countDirty(){
  const t = getLocalTerms().filter(x=>x && x.dirty).length;
  const r = getLocalReview().filter(x=>x && x.dirty).length;
  return t + r;
}
function updateDirtyCount(){
  const el = document.getElementById("sync-dirty-count");
  if(el) el.textContent = String(countDirty());
}
function setSyncStatus(msg){
  const el = document.getElementById("sync-status");
  if(el) el.textContent = msg;
}

// -------- Supabase data access (normalized tables) --------
async function supaRequireSession(){
  const c = initSupabase();
  if(!c) throw new Error("Supabase not configured");
  const { data, error } = await c.auth.getSession();
  if(error) throw error;
  if(!data.session) throw new Error("Auth session missing");
  return { client: c, session: data.session };
}

async function supaFetchUserTerms(){
  const { client } = await supaRequireSession();
  const { data, error } = await client
    .from(USER_TERMS_TABLE)
    .select("*")
    .order("updated_at", { ascending: false });
  if(error) throw error;
  return data || [];
}

async function supaUpsertUserTerms(rows){
  const { client, session } = await supaRequireSession();
  const now = new Date().toISOString();
  const payload = (rows || []).map(r => ({
    id: r.id || undefined,
    user_id: session.user.id,
    english: r.english ?? null,
    german: r.german ?? null,
    latin: r.latin ?? null,
    slovak: r.slovak ?? null,
    spanish: r.spanish ?? null,
    source_dataset: r.source_dataset ?? null,
    notes: r.notes ?? null,
    created_at: r.created_at ?? undefined,
    updated_at: now
  }));
  if(payload.length === 0) return;
  const { error } = await client
    .from(USER_TERMS_TABLE)
    .upsert(payload, { onConflict: "id" });
  if(error) throw error;
}

async function supaFetchUserReview(){
  const { client } = await supaRequireSession();
  const { data, error } = await client
    .from(USER_REVIEW_TABLE)
    .select("*")
    .order("updated_at", { ascending: false });
  if(error) throw error;
  return data || [];
}

async function supaUpsertUserReview(rows){
  const { client, session } = await supaRequireSession();
  const now = new Date().toISOString();
  const payload = (rows || []).map(r => ({
    id: r.id || undefined,
    user_id: session.user.id,
    user_term_id: r.user_term_id ?? null,
    base_term_key: r.base_term_key ?? null,
    base_dataset: r.base_dataset ?? null,
    difficulty: Number.isFinite(r.difficulty) ? r.difficulty : 0,
    last_seen: r.last_seen ?? null,
    next_due: r.next_due ?? null,
    created_at: r.created_at ?? undefined,
    updated_at: now
  }));
  if(payload.length === 0) return;
  const { error } = await client
    .from(USER_REVIEW_TABLE)
    .upsert(payload, { onConflict: "id" });
  if(error) throw error;
}

// -------- Sync (manual) --------
function mergeById(localRows, remoteRows){
  const map = new Map();
  for(const r of (remoteRows||[])){
    if(r && r.id) map.set(r.id, { ...r, dirty: false });
  }
  for(const l of (localRows||[])){
    if(!l) continue;
    if(l.id){
      const existing = map.get(l.id);
      if(l.dirty) map.set(l.id, { ...(existing||{}), ...l, dirty: true });
      else if(!existing) map.set(l.id, { ...l, dirty: false });
    } else {
      map.set("local-" + Math.random().toString(16).slice(2), { ...l, dirty: true });
    }
  }
  return Array.from(map.values());
}

async function syncNow(){
  if(!state.currentUserEmail){ setSyncStatus("login required"); return; }
  try{
    setSyncStatus("syncing...");
    const [remoteTerms, remoteReview] = await Promise.all([supaFetchUserTerms(), supaFetchUserReview()]);
    const mergedTerms = mergeById(getLocalTerms(), remoteTerms);
    const mergedReview = mergeById(getLocalReview(), remoteReview);
    setLocalTerms(mergedTerms);
    setLocalReview(mergedReview);

    const dirtyTerms = mergedTerms.filter(x=>x && x.dirty);
    const dirtyReview = mergedReview.filter(x=>x && x.dirty);

    for(const t of dirtyTerms){
      if(!t.id) t.id = (crypto && crypto.randomUUID) ? crypto.randomUUID() : (Date.now().toString(16)+Math.random().toString(16).slice(2));
    }
    for(const r of dirtyReview){
      if(!r.id) r.id = (crypto && crypto.randomUUID) ? crypto.randomUUID() : (Date.now().toString(16)+Math.random().toString(16).slice(2));
    }

    await Promise.all([supaUpsertUserTerms(dirtyTerms), supaUpsertUserReview(dirtyReview)]);

    for(const t of mergedTerms) t.dirty = false;
    for(const r of mergedReview) r.dirty = false;
    setLocalTerms(mergedTerms);
    setLocalReview(mergedReview);

    localStorage.setItem("cache/last_sync_at", new Date().toISOString());
    setSyncStatus("synced " + new Date().toLocaleString());
  }catch(e){
    console.error(e);
    setSyncStatus("sync failed: " + (e.message || e));
  }
}

// --- Utilities: File loader that works with both http and file:// protocols ---
async function loadFile(filename) {
  try {
    const response = await fetch(filename);
    return await response.text();
  } catch (e) {
    return new Promise((resolve, reject) => {
      const xhr = new XMLHttpRequest();
      xhr.open('GET', filename, true);
      xhr.onload = () => resolve(xhr.responseText);
      xhr.onerror = () => {
        try {
          const syncXhr = new XMLHttpRequest();
          syncXhr.open('GET', filename, false);
          syncXhr.send();
          if (syncXhr.status === 200) resolve(syncXhr.responseText);
          else reject(new Error(`Failed to load ${filename}`));
        } catch (finalError) {
          reject(finalError);
        }
      };
      xhr.send();
    });
  }
}

// --- Utilities: robust CSV parser for quoted fields (RFC4180-ish) ---
function parseCSVLines(text){
  const rows = [];
  let cur = [];
  let curField = '';
  let inQuotes = false;

  const firstLine = text.split(/\r?\n/, 1)[0] || '';
  const semiCount = (firstLine.match(/;/g) || []).length;
  const commaCount = (firstLine.match(/,/g) || []).length;
  const delimiter = semiCount > commaCount ? ';' : ',';

  for(let i=0;i<text.length;i++){
    const ch = text[i];
    const next = text[i+1];
    if(inQuotes){
      if(ch === '"'){
        if(next === '"'){ curField += '"'; i++; } else { inQuotes = false; }
      } else { curField += ch; }
    } else {
      if(ch === '"') { inQuotes = true; }
      else if(ch === delimiter){ cur.push(curField); curField = ''; }
      else if(ch === '\r') continue;
      else if(ch === '\n'){ cur.push(curField); rows.push(cur); cur = []; curField = ''; }
      else curField += ch;
    }
  }
  if(curField !== '' || cur.length>0) { cur.push(curField); rows.push(cur); }
  return rows;
}

function rowsToObjects(rows){
  if(!rows || rows.length === 0) return [];
  const headers = rows[0].map(h=>h.trim());
  const objs = [];
  for(let i=1;i<rows.length;i++){
    const row = rows[i];
    const obj = {};
    for(let j=0;j<headers.length;j++) obj[headers[j]] = (row[j]||'').trim();
    objs.push(obj);
  }
  return objs;
}

// --- Translation loader ---
const translations = {};
async function loadTranslations(){
  try{
    const txt = await loadBaseFile('App translations.csv');
    const rows = parseCSVLines(txt);
    if(rows.length < 1) throw new Error('No data in translations file');

    Object.keys(translations).forEach(k => delete translations[k]);

    const headers = rows[0].map(h => h.trim());
    for(let i = 1; i < headers.length; i++) {
      const lang = headers[i];
      translations[lang] = {};
    }

    for(let i = 1; i < rows.length; i++) {
      const row = rows[i];
      const key = row[0].trim();
      if(!key) continue;

      for(let j = 1; j < headers.length; j++) {
        const lang = headers[j];
        const text = (row[j] || '').trim();
        if(text) translations[lang][key] = text;
      }
    }

    const variations = {
      'english': 'English',
      'deutch': 'Deutch',
      'deutsch': 'Deutch',
      'german': 'Deutch',
      'slovensky': 'Slovensky',
      'slovak': 'Slovensky',
      'espanol': 'Spanish',
      'español': 'Spanish',
      'spanish': 'Spanish',
      'norsk': 'Norwegian',
      'norwegian': 'Norwegian',
      'islenska': 'Icelandic',
      'íslenska': 'Icelandic',
      'icelandic': 'Icelandic'
    };
    Object.entries(variations).forEach(([variant, standard]) => {
      if(translations[standard]) translations[variant] = translations[standard];
    });
  }catch(e){
    console.warn('Translations load failed:', e.message);
  }
}

// --- Medical terms loader ---
let medicalTerms = [];
async function loadMedicalTerms() {
  try {
    const txt = await loadBaseFile('medical_terms.csv');
    const rows = parseCSVLines(txt);
    if(rows.length < 1) throw new Error('No data in medical terms file');
    medicalTerms = rowsToObjects(rows);
  } catch(e) {
    console.warn('Medical terms load failed:', e.message);
    medicalTerms = [];
  }
}

// --- UI wiring and i18n ---
let state = { language: localStorage.getItem('app_language') || 'English', currentUser: null, currentUserEmail: null };

// ===== Language handling =====
const LANG_CANON = {
  'english':'English',
  'deutch':'Deutch',
  'deutsch':'Deutch',
  'german':'Deutch',
  'slovensky':'Slovensky',
  'slovak':'Slovensky',
  'spanish':'Spanish',
  'espanol':'Spanish',
  'español':'Spanish',
  'norwegian':'Norwegian',
  'norsk':'Norwegian',
  'icelandic':'Icelandic',
  'islenska':'Icelandic',
  'íslenska':'Icelandic'
};

function normalizeLanguage(lang){
  const raw = String(lang || '').trim();
  if(!raw) return 'English';
  const key = raw.toLowerCase();
  return LANG_CANON[key] || raw;
}

function getBaseSearchField(){
  const lang = normalizeLanguage(state.language);
  // Map UI language -> base CSV column
  if(lang === 'Deutch') return 'german_translation';
  if(lang === 'Slovensky') return 'slovak_translation';
  if(lang === 'Spanish') return 'spanish_translation';
  // If you later add these columns to your base CSV, update mapping here
  if(lang === 'Norwegian') return 'norvegian_translation';
  if(lang === 'Icelandic') return 'icelandic_translation';
  return 'english_translation';
}

function getUserSearchField(){
  const lang = normalizeLanguage(state.language);
  // Map UI language -> user_terms object field
  if(lang === 'Deutch') return 'german';
  if(lang === 'Slovensky') return 'slovak';
  if(lang === 'Spanish') return 'spanish';
  if(lang === 'Norwegian') return 'norwegian';
  if(lang === 'Icelandic') return 'icelandic';
  return 'english';
}

const BASE_SEARCH_FIELDS = [
  "latin_translation",
  "english_translation",
  "german_translation",
  "slovak_translation",
  "spanish_translation",
  "norvegian_translation",
  "norwegian_translation",
  "icelandic_translation",
  "english_definition",
  "german_definition",
  "slovak_definition",
  "spanish_definition",
  "norwegian_definition",
  "icelandic_definition",
  "genitive",
  "accusative"
];

const USER_SEARCH_FIELDS = [
  "latin",
  "english",
  "german",
  "slovak",
  "spanish",
  "norwegian",
  "icelandic",
  "notes"
];

const USER_FIELD_MAP = {
  english_translation: "english",
  german_translation: "german",
  slovak_translation: "slovak",
  latin_translation: "latin",
  spanish_translation: "spanish",
  norwegian_translation: "norwegian",
  norvegian_translation: "norwegian",
  icelandic_translation: "icelandic"
};

function includesQuery(value, query){
  return String(value || "").toLowerCase().includes(query);
}

function matchAnyField(row, fields, query){
  for(const f of fields){
    if(includesQuery(row[f], query)) return true;
  }
  return false;
}

function mapUserFieldFromBase(baseField){
  return USER_FIELD_MAP[baseField] || baseField;
}

async function setLanguage(lang){
  const canonical = normalizeLanguage(lang);
  state.language = canonical;
  localStorage.setItem('app_language', canonical);

  const sel = document.getElementById('language');
  if(sel) sel.value = canonical;

  // Ensure translations are loaded at least once
  if(!translations || Object.keys(translations).length === 0){
    try{ await loadTranslations(); }catch(e){}
  }

  applyTranslationsToDom();

  // If user is currently searching, rerender results instantly
  const si = document.getElementById('search-input');
  if(si && si.value && si.value.trim().length >= 2){
    si.dispatchEvent(new Event('input', { bubbles:true }));
  }
}


function t(key){
  const lang = state.language;
  if(translations[lang] && translations[lang][key]) return translations[lang][key];
  if(translations['English'] && translations['English'][key]) return translations['English'][key];
  return key;
}

function applyTranslationsToDom(){
  document.querySelectorAll('[data-i18n]').forEach(el => {
    const k = el.getAttribute('data-i18n');
    el.textContent = t(k);
  });
  document.querySelectorAll('[data-i18n-placeholder]').forEach(el => {
    const k = el.getAttribute('data-i18n-placeholder');
    el.placeholder = t(k);
  });
}

function showScreen(id){
  document.querySelectorAll('.screen').forEach(s=>s.classList.add('hidden'));
  const el = document.getElementById(id);
  if(el) el.classList.remove('hidden');
}

/* === NEW: auth UI (cog only after login + header user) === */
function updateAuthUI(){
  const cog = document.getElementById('settings-toggle');
  const who = document.getElementById('header-whoami');
  const whoUser = document.getElementById('header-user');

  const loggedIn = !!state.currentUser;
  if(loggedIn){
    cog.classList.remove('hidden');
    who.classList.remove('hidden');
    whoUser.textContent = state.currentUser;
  } else {
    cog.classList.add('hidden');
    who.classList.add('hidden');
    whoUser.textContent = '—';
    // ensure settings is closed if user logs out
    document.getElementById('settings-sidebar').classList.remove('open');
    document.getElementById('settings-overlay').classList.remove('open');
  }
}

async function logoutToLogin(){
  try{
    await supaSignOut();
  }catch(e){
    console.warn("Sign out failed:", e);
  }
  state.currentUser = null;
  state.currentUserEmail = null;
  document.getElementById('current-user').textContent = "(none)";
  updateAuthUI();
  document.getElementById('login-form').classList.remove('hidden');
  document.getElementById('register-form').classList.add('hidden');
  showScreen('screen-login');
}

async function init(){
  // Always try to refresh base CSV cache first (newest possible version)
  try{ await refreshBaseFilesCache(); }catch(e){ console.warn('Base CSV refresh skipped:', e); }

  await Promise.all([loadTranslations(), loadMedicalTerms()]);

    // Apply language instantly (no reload needed)
    await setLanguage(state.language);
// Settings sidebar handling
  const settingsBtn = document.getElementById('settings-toggle');
  const sidebar = document.getElementById('settings-sidebar');
  const overlay = document.getElementById('settings-overlay');

  function openSettings(){
    sidebar.classList.add('open');
    overlay.classList.add('open');
  }
  function closeSettings(){
    sidebar.classList.remove('open');
    overlay.classList.remove('open');
  }
  function toggleSettings(){
    if(sidebar.classList.contains('open')) closeSettings();
    else openSettings();
  }

  if(settingsBtn) settingsBtn.addEventListener('click', toggleSettings);
  if(overlay) overlay.addEventListener('click', closeSettings);

  // Hero language buttons
  document.querySelectorAll('.lang-btn').forEach(btn=>{
    btn.addEventListener('click', async (e)=>{
      e.preventDefault();
      const lang = btn.getAttribute('data-lang');
      await setLanguage(lang);
    });
  });
on('to-login','click', ()=> showScreen('screen-login'));
  on('to-register','click', ()=> {
    showScreen('screen-login');
    document.getElementById('login-form').classList.add('hidden');
    document.getElementById('register-form').classList.remove('hidden');
  });

  function openGuestModal(){
    const overlay = document.getElementById('guest-overlay');
    if(overlay) overlay.classList.remove('hidden');
  }
  function closeGuestModal(){
    const overlay = document.getElementById('guest-overlay');
    if(overlay) overlay.classList.add('hidden');
  }

  on('continue-guest','click', ()=> openGuestModal());
  on('guest-back','click', ()=> closeGuestModal());
  on('guest-continue','click', ()=>{
    closeGuestModal();
    showScreen('screen-submenu');
  });

  document.getElementById('language').value = state.language;
  on('language','change', async (e)=>{
    await setLanguage(e.target.value);
  });
on('btn-show-register','click', ()=>{
    document.getElementById('login-form').classList.add('hidden');
    document.getElementById('register-form').classList.remove('hidden');
  });
  on('btn-show-login','click', ()=>{
    document.getElementById('login-form').classList.remove('hidden');
    document.getElementById('register-form').classList.add('hidden');
  });

  on('btn-register','click', async () => {
    clearLoginStatus();
    const username = document.getElementById('reg-username').value.trim();
    const password = document.getElementById('reg-password').value;
    const confirm = document.getElementById('reg-password-confirm').value;
    const msg = document.getElementById('register-msg');
    msg.textContent='';

    if (!username || !password) {
      setLoginStatus("Please fill all fields", "error");
      return;
    }
    if (password !== confirm) {
      setLoginStatus("Passwords do not match", "error");
      return;
    }

    const email = normalizeLoginIdentifier(username);

    try {
      setLoginStatus("Creating account…");
      await supaSignUp(email, password);

      const session = await supaGetSession();
      if (session) {
        setLoginStatus("Account created. You can log in now.", "ok");
      } else {
        setLoginStatus("Account created. Please confirm your email, then log in.", "info");
      }
      msg.textContent = t('Registration successful! You can now log in.') || 'Registration successful! You can now log in.';
      document.getElementById('reg-username').value='';
      document.getElementById('reg-password').value='';
      document.getElementById('reg-password-confirm').value='';
    } catch (e) {
      console.error(e);
      setLoginStatus("Registration failed: " + e.message, "error");
      msg.textContent = (e.message || String(e));
    }
  });

  on('btn-login','click', async () => {
    clearLoginStatus();
    const username = document.getElementById('username').value.trim();
    const password = document.getElementById('password').value;
    const msg = document.getElementById('login-msg');
    msg.textContent='';

    if (!username || !password) {
      setLoginStatus("Enter username and password", "error");
      return;
    }

    const email = normalizeLoginIdentifier(username);

    try {
      setLoginStatus("Signing in…");
      await supaSignIn(email, password);

      state.currentUser = username;
      state.currentUserEmail = email;

      // Update who is logged in (settings + header)
      document.getElementById('current-user').textContent = username;
      updateAuthUI();

      setLoginStatus("Signed in. Sync active.", "ok");
      showScreen("screen-submenu");

// Pull newest base CSVs into offline cache on login (if available), then reload from cache
try{
  await refreshBaseFilesCache();
  await Promise.all([loadTranslations(), loadMedicalTerms()]);
  applyTranslationsToDom();
}catch(e){
  console.warn("Base CSV refresh failed (offline/local only):", e);
}

try{
        setSyncStatus("loading...");
        const [remoteTerms, remoteReview] = await Promise.all([supaFetchUserTerms(), supaFetchUserReview()]);
        setLocalTerms(mergeById(getLocalTerms(), remoteTerms));
        setLocalReview(mergeById(getLocalReview(), remoteReview));
        setSyncStatus("ready");
      }catch(e){
        console.warn("Initial remote load failed (offline/local only):", e);
        setSyncStatus("offline/local only");
      }

    } catch (e) {
      console.error(e);
      setLoginStatus("Login failed: " + e.message, "error");
      msg.textContent = t('Invalid credentials.') || 'Invalid credentials.';
    }
  });

  on('to-search','click', ()=> { showScreen('screen-search'); });
  on('to-entry','click', ()=> { showScreen('screen-entry'); });
  on('to-quiz','click', ()=> { showScreen('screen-quiz'); });

  // moved to settings sidebar (same IDs)
  on('to-menu','click', ()=> { showScreen('screen-menu'); });
  on('to-login-from-settings','click', async ()=> { await logoutToLogin(); });
  on('btn-sync','click', async ()=>{ await syncNow(); });

  updateDirtyCount();

  const searchInput = document.getElementById('search-input');
  const resultsDiv = document.getElementById('search-results');

  searchInput.addEventListener('input', ()=>{
    const q = searchInput.value.trim().toLowerCase();
    resultsDiv.innerHTML='';
    if(q.length<2) return;

    const results = [];
    const seenBase = new Set();
    const seenUser = new Set();
    const langField = getBaseSearchField();
    const userField = getUserSearchField();

    for(const r of medicalTerms){
      if(includesQuery(r[langField], q)){
        results.push({ kind:'base', row:r });
        seenBase.add(r);
      }
    }

    for(const t of getLocalTerms()){
      if(includesQuery(t && t[userField], q)){
        results.push({ kind:'user', row:t });
        seenUser.add(t);
      }
    }

    if(results.length === 0){
      for(const r of medicalTerms){
        if(!seenBase.has(r) && matchAnyField(r, BASE_SEARCH_FIELDS, q)){
          results.push({ kind:'base', row:r });
          seenBase.add(r);
        }
      }
      for(const t of getLocalTerms()){
        if(!seenUser.has(t) && matchAnyField(t || {}, USER_SEARCH_FIELDS, q)){
          results.push({ kind:'user', row:t });
          seenUser.add(t);
        }
      }
    }

    if(results.length===0){
      resultsDiv.textContent = t('No matching results found.') || 'No matching results found.';
      return;
    }

    for(const item of results){
      const el = document.createElement('div');
      el.className='result';
      if(item.kind === 'base'){
        const row = item.row;
        const head = (row[langField]||row['latin_translation']||row['english_translation']||'').trim();
        const def = (row['english_definition']||'').trim();
        el.innerHTML = `<strong>${head}</strong>${def?`<div class="muted" style="margin-top:6px">${def}</div>`:''}
          <div class="kv">
            <div class="k">Latin</div><div class="v">${row['latin_translation']||''}</div>
            <div class="k">English</div><div class="v">${row['english_translation']||''}</div>
            <div class="k">German</div><div class="v">${row['german_translation']||''}</div>
            <div class="k">Slovak</div><div class="v">${row['slovak_translation']||''}</div>
          </div>`;
      } else {
        const row = item.row;
        const head = (row[userField]||row.latin||row.english||'').trim();
        const def = (row.notes||'').trim();
        el.innerHTML = `<strong>${head}</strong>${def?`<div class="muted" style="margin-top:6px">${def}</div>`:''}
          <div class="kv">
            <div class="k">Latin</div><div class="v">${row.latin||''}</div>
            <div class="k">English</div><div class="v">${row.english||''}</div>
            <div class="k">German</div><div class="v">${row.german||''}</div>
            <div class="k">Slovak</div><div class="v">${row.slovak||''}</div>
          </div>`;
      }
      resultsDiv.appendChild(el);
    }
  });

  on('search-back','click', ()=> showScreen('screen-submenu'));

  on('save-term','click', async ()=>{
    if(!state.currentUser){
      document.getElementById('entry-msg').textContent = t('Please login first.') || 'Please login first.';
      return;
    }
    const fields = [...document.querySelectorAll('#entry-fields [data-field]')];
    const raw = {};
    for(const el of fields) raw[el.dataset.field] = el.value.trim();

    const term = {
      id: null,
      english: raw.english_translation || null,
      german: raw.german_translation || null,
      latin: raw.latin_translation || null,
      slovak: raw.slovak_translation || null,
      spanish: raw.spanish_translation || null,
      notes: raw.english_definition || raw.german_definition || null,
      source_dataset: "manual_entry",
      created_at: new Date().toISOString(),
      updated_at: new Date().toISOString(),
      dirty: true
    };

    const terms = getLocalTerms();
    terms.unshift(term);
    setLocalTerms(terms);

    document.getElementById('entry-msg').textContent =
      (t('Term saved successfully!') || 'Term saved successfully!') + ' (saved locally — press Sync)';
    fields.forEach(f=>f.value='');
  });

  on('entry-back','click', ()=> showScreen('screen-submenu'));
  on('start-quiz','click', ()=> startQuiz());
  on('quiz-back','click', ()=> showScreen('screen-submenu'));

  // initial state: not logged in => hide cog + header whoami
  updateAuthUI();

  showScreen('screen-menu');
  applyTranslationsToDom();
}

function startQuiz(){
  const from = document.getElementById('quiz-from').value;
  const to = document.getElementById('quiz-to').value;
  const fromUser = mapUserFieldFromBase(from);
  const toUser = mapUserFieldFromBase(to);
  const area = document.getElementById('quiz-area');
  area.innerHTML='';
  const scoreEl = document.getElementById('quiz-score');
  scoreEl.textContent='';

  const pool = [];
  for(const r of medicalTerms) if(r[from] && r[to]) pool.push({from: r[from], to: r[to]});
  if(state.currentUser){
    const added = getLocalTerms();
    for(const r of added) if(r && r[fromUser] && r[toUser]) pool.push({from: r[fromUser], to: r[toUser]});
  }
  if(pool.length === 0){
    area.textContent = t('No pairs available for this selection.') || 'No pairs available for this selection.';
    return;
  }

  shuffle(pool);
  const quizItems = pool.slice(0, Math.min(5,pool.length));
  let score=0;

  quizItems.forEach((it, idx)=>{
    const qdiv = document.createElement('div');
    qdiv.className='quiz-item';
    const q = document.createElement('div');
    q.innerHTML = `<strong>Q${idx+1}:</strong> ${it.from}`;
    qdiv.appendChild(q);

    const choices = [it.to];
    for(let i=0;i<20 && choices.length<4;i++){
      const cand = pool[Math.floor(Math.random()*pool.length)].to;
      if(cand && !choices.includes(cand)) choices.push(cand);
    }
    shuffle(choices);

    const ul = document.createElement('div');
    ul.className='choices';
    choices.forEach(ch=>{
      const btn = document.createElement('button');
      btn.textContent=ch;
      btn.addEventListener('click', ()=>{
        if(btn.classList.contains('answered')) return;
        btn.classList.add('answered');
        if(ch===it.to){ btn.style.background='lightgreen'; score++; }
        else { btn.style.background='indianred'; }
        scoreEl.textContent = `${t('score')||'Score'}: ${score} / ${quizItems.length}`;
      });
      ul.appendChild(btn);
    });
    qdiv.appendChild(ul);
    area.appendChild(qdiv);
  });

  scoreEl.textContent = `${t('score')||'Score'}: ${score} / ${quizItems.length}`;
}

function shuffle(arr){
  for(let i=arr.length-1;i>0;i--){
    const j=Math.floor(Math.random()*(i+1));
    [arr[i],arr[j]]=[arr[j],arr[i]];
  }
}

window.addEventListener('DOMContentLoaded', ()=>{ init(); });
  </script>
</body>
</html>
